---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "# ",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

[![Travis build status](https://travis-ci.org/SymbolixAU/spatialwidget.svg?branch=master)](https://travis-ci.org/SymbolixAU/spatialwidget)
[![Coverage status](https://codecov.io/gh/SymbolixAU/spatialwidget/branch/master/graph/badge.svg)](https://codecov.io/github/SymbolixAU/spatialwidget?branch=master)

# spatialwidget

### What's a 'spatialwidget'

Well, what do these packages have in common?

- leaflet
- googleway
- mapdeck
- mapview
- tmap

1. They are all [htmlwidgets](http://www.htmlwidgets.org/)
2. They all plot interactive maps
3. They all take data from R and display it on the maps.

And on 22nd August 2017 on the [r-spatial github page](https://github.com/r-spatial/discuss/issues/15#issue-251762127) it was requested if there could be a common package which could be shared by all the interactive web-plotting libraries

> Currently there is code in the leaflet package that extracts data from sp and sf objects and converts it into a dataframe that is then passed to the Javascript side (by converting it into a JSON).
This code is fairly generic and not really dependent on anything leaflet specific. It makes a lot of sense to take out this code and make it a package of its own. That way we can build other web plotting R packages to wrap say d3.geo or mapboxGL or cesium and reuse a major chunk of the code that takes data from spatial objects and passes it to Javascript.

so **spatialwidget** is my attempt at this library.

### What does it do?

It takes a simple feature object (`sf`), plus some user-supplied arguments, and converts the data into JSON, ready for plotting/ parsing in whatever javascript library you chose. 

### Can you show me?

Sure. In this example I'm using the `capitals` data, which is an `sf` object of all the capital cities.

```{r}
library(spatialwidget)
library(sf)
sf <- spatialwidget::capitals
sf
```

As each capital is a POINT, you can use `widget_point()` to conver it to JSON. 

```{r}
l <- widget_point( data = sf[1:2, ], fill_colour = "country" , legend = F)
```

Each row of `capitals` has been converted into a JSON object. And all these objects are within an array.

Look, here are the first two rows of `capitals` as JSON

```{r}
sf[1:2, ]
jsonlite::prettify( l$data )
```

You can see that the coordinates are inside a `geometry` object, and the user-defined `fill_colour` is within the `properties` object. 

### That looks a lot like GeoJSON

Well spotted. But it's not quite GeoJSON for a very good reason. 

Some plotting libraries can use more than one geometry, such as [mapdeck::add_arc()](https://github.com/SymbolixAU/mapdeck#basic-use), which uses an origin and destination. So spatialwidget needs to handle multiple geometries.

Typical GeoJSON will take the form

```js
[{"type":"Feature", "properties":{"stroke_colour":"#440154FF"},"geometry":{"type":"Point","coordinates":[0,0]}}]
```

Whereas I've nested the geometries one-level deeper, so the pseudo-GeoJSON i'm using takes the form

```js
[{"type":"Feature", "properties":{"stroke_colour":"#440154FF"},"geometry":{"myGeometry":{"type":"Point","coordinates":[0,0]}}}]
```

Where the `myGeometry` object is defined on a per-application bases. You are free to call this whatever you want inside your library. 

### That sort of makes sense, but can you show me an example with multiple geometries?

Yep. 

Say we want to generate an arc-map showing an arc between Sydney and all the other capitals cities. After a bit of manipulation we can make a `sf` object with two geometry columns

```{r}
sf_sydney <- capitals[ capitals$country == "Australia", ]
sf_world <- capitals[ capitals$country != "Australia", ]

sf <- cbind( sf_world, sf_sydney[rep(1, nrow(sf_world)), ])
sf
```


NOTE: I'm still writing the R function to handle OD, but here's how you call the `rcpp` function

```{r}

data_types <- vapply( sf, function(x) class(x)[[1]], "")
l <- list()
l[["origin"]] <- "geometry"
l[["destination"]] <- "geometry.1"
l[["fill_colour"]] <- "country"
js <- spatialwidget:::rcpp_widget_point( sf[1:2, ], data_types, l, c("origin","destination") )

jsonlite::prettify( js$data )

```

Notice now the `geometry` object has within it an `origin` and a `destination`


### How do I use it in my package?

TODO: examples of c++ integration



