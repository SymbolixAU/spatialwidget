---
title: "spatialwidget"
author: "D Cooley"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "# "
)

library(sf)
library(geojsonsf)

```

## Spatialwidget

This package is designed to convert R data to JSON, ready for plotting on a map in an `htmlwidget`. 

## Design

The basic idea of this package is to take a data.frame 

```{r}
n <- 100
set.seed(20181125)
lons <- sample(seq(-180, 180, by = 0.001), size = n)
lats <- sample(seq(-90, 90, by = 0.001), size = n)

df <- data.frame(
  myLon = lons
  , myLat = lats
  , val = rnorm(n=n)
  , samp = sample(1:100, size = n)
)
head( df )
```

And a list specifying which columns of `df` will be used as colouring values, plus other options, such as whether a legend is required,

```{r}
lst <- list(
  lon = "lon"
  , lat = "lat"
  , fill_colour = "val"
  , fill_opacity = "samp"
  , legend = T
  , na_colour = "#808080FF"
)
```

converts the required values of `df` into colours 

```{r}

colours <- colourvalues::colour_values( df$val, alpha = df$samp, n_summaries = 5 )
df$val <- colours$colours

head( df )
```

and constructs the legend

```{r}
legend <- list( 
  colours$summary_values
  , colours$summary_colours
)

legend
```

and then converts the remaining data into the pseudo-GeoJSON

```{r}
l <- spatialwidget:::rcpp_geojson_df( df, list(geometry = c("myLon","myLat")))

substr( l, 1, 500) 

```


Notice the `val` columns is now a hex colour, and the `myLon` and `myLat` have been converted into `Point` coordinates. 

This pseudo-GeoJSON can then be parsed in a htmlwidget javascript function.

---

There are R functions you can call, but these are limited. You will primarily use the C++ functions.


## R Interface

There are 4 R functions you can call for creating POINTs, LINEs, POLYGONs or origin-destination shapes. 

Each of these functions returns a list with two elements, `data` and `legend`.

- data : the R `data.frame` or `sf` object converted to pseudo-GeoJSON
- legend : a summary of the values and colours suitable for a legend on the map

### Pseudo-GeoJSON

The `data` is returned as **pseudo-GeoJSON** because some plotting libraries can use more than one geometry, such as `mapdeck::add_arc()`, which uses an origin and destination. So spatialwidget needs to handle multiple geometries.

Typical GeoJSON will take the form

```js
[{"type":"Feature", "properties":{},"geometry":{"type":"Point","coordinates":[0,0]}}]
```

Whereas I’ve nested the geometries one-level deeper, so the pseudo-GeoJSON i’m using takes the form

```js
[{"type":"Feature", "properties":{},"geometry":{"myGeometry":{"type":"Point","coordinates":[0,0]}}}]
```

Where the myGeometry object is defined on a per-application bases. You are free to call this whatever you want inside your library.



### Points

```{r, echo = FALSE}
library(spatialwidget)
```

```{r}
l <- widget_point( capitals[1:2, ], fill_colour = "country", legend = T )
l
```

### Lines

```{r}
l <- widget_line( roads[1:2, ], stroke_colour = "ROAD_NAME", legend = T )
l
```

### Polygon

```{r}
l <- widget_polygon( melbourne[1:2, ], fill_colour = "AREASQKM16", legend = F)
l
```


The capabilities of these functions is limited. You get more control by implementing your own R functions and using the c++ API. 

---

## C++ API

There are 5 functions you can call, 4 will return pseudo-GeoJSON, and the other will return encoded polylines. 

Three of functions retuning geojson are overloaded, so you use the same function name, but supply different arguments. 
The `create_geojson_downcast()` is used for down-casting MULTI geometry objects into their equivalent non-MULTI objects. (For example, if you have a MULTIPOINT object, but the widget can only handle POINTs, you will have to down-cast the MULTIPOINT to POINTS)

```c++
Rcpp::List create_geojson() // 3 overloads

Rcpp::List create_geojson_downcast()

Rcpp::List create_polyline()
```

Each function uses these same 8 common arguments

Common arguments
---

### Rcpp::DataFrame data

This will either be a data.frame with lon & lat columns, or an `sf` object.


### Rcpp::List data_types

A named vector. Each name is the columns of `data`, and the values are the `r` data types of the column. Only one value per name is accepted. This is used to help determine how the legend values should be formatted. 

An example is

```{r}
df <- data.frame(id = 1:5, val = letters[1:5])
data_types <- vapply( df, function(x) class(x)[[1]], "")
data_types
```

### Rcpp::List params

A named list. The names are the arguments of the calling R function which will be supplied to the javascript widget. These are typically columns of `data`, or a single value that will be applied to all rows of `data`.

For example, the R function will look like

```r
add_layer <- function(
  data, 
  fill_colour = NULL,
  stroke_colour = NULL,
  another_argument = TRUE
)
```

And the list passed to c++ will be

```r
l <- list()
l[["fill_colour"]] <- force( fill_colour )
l[["stroke_colour"]] <- force( stroke_colour ) 
```

In this case, the `another_argument` is not passed to the javascript widget as part of the data, so we don't include it in our list.

The javascript function will then access the `stroke_colour` and `fill_colour` properties from the data. This code is taken from the javascript binding of `mapdeck::add_polygon()`

```js
// this function is called when an `sf` object is used in R
const polygonLayer = new PolygonLayer({
    getLineColor: d => hexToRGBA2( d.properties.stroke_colour ),
    getFillColor: d => hexToRGBA2( d.properties.fill_colour ),
  });
```

### Rcpp::List lst_defaults

Either a named list, or an empty list.

You can use this list to supply default values to the widget.

```c++

Rcpp::List scatterplot_defaults(int n) {
	return Rcpp::List::create(
		_["fill_colour"] = mapdeck::defaults::default_fill_colour(n)
	);
}

// use Either a named list, 
Rcpp::List lst_defaults = scatterplot_defaults( data_rows );  // initialise with defaults

// or an empty object
Rcpp::List lst_defaults;

```

### std::unordered_map< std::string, std::string > layer_colours

A c++ `unorderd_map` specifying colours and their associated opacity. 

```c++
std::unordered_map< std::string, std::string > polygon_colours = {
  	{ "fill_colour", "fill_opacity" },
  	{ "stroke_colour", "stroke_opacity"}
  };
```

These values will match the colour parameters used in the `params` list

```r
l <- list()
l[["fill_colour"]] <- force( fill_colour )
l[["stroke_colour"]] <- force( stroke_colour ) 
```

But you don't have to supply the opacity, it will be set to 'opaque' by default. 


### Rcpp::StringVector layer_legend

A vector of the colour values you want to use in a lenged. 

```c++
const Rcpp::StringVector polygon_legend = Rcpp::StringVector::create(
  	"fill_colour", "stroke_colour"
  );
```

In this example, both `fill_colour` and `stroke_colour` will be returned in the legend data. 

### int data_rows

The number of rows of `data`. 

### Rcpp::StringVector parameter_exclusions

A vector describing the elements of `params` which will be excluded from the final JSON data. 

```c++
Rcpp::StringVector parameter_exclusions = Rcpp::StringVector::create("palette","legend","na_colour");
```



### bool jsonify_legend

A logical value indicating if you want the legend data returned as JSON (TRUE) or a a list (FALSE)


Function-dependent arguments
---

#### geometry_columns

Either an `Rcpp::List` or `Rcpp::StringVector`. 

The `List` is used for `data.frame`s with lon & lat columns. 

```r
df <- data.frame(lon = 0, lat = 0)
geometry_column <- list( geometry = c("lon","lat") )
```

The `StringVector` is used for `sf` objects to specify the geometry columns.

```r
sf <- sf::st_sf( origin = sf::st_sfc( sf::st_point(c(0,0 ) ) ) )
geometry_column <- c( "origin" )
```

#### bool elevation

The `elevation` argument is used to indicate the `data.frame` has a column used to specify the elevation of the geometry. When using the elevation you also need to supply this column in the `geometry_column` list. 

```r
geometry_column <- list( geometry = c("lon","lat","elevation") )
```

### Function definitions

Here are the 4 function signatures


```c++
/*
 * expects `data` to be an sf object, where the geometry_columns is a string vector
 * of the sfc colunm names (of sf) you want to use as the geometry object inside the GeoJSON 
 */
inline Rcpp::List create_geojson(
    Rcpp::DataFrame& data,
    Rcpp::List& data_types,
    Rcpp::List& params,
    Rcpp::List& lst_defaults,
    std::unordered_map< std::string, std::string >& layer_colours,
    Rcpp::StringVector& layer_legend,
    int& data_rows,
    Rcpp::StringVector& geometry_columns,
    bool jsonify_legend
  )

```

```c++
/*
 * expects `data` to be an sf object, where the geometry_columsn is a string vector
 * of the sfc column names (of sf) you want to use as the geometry object inside the GeoJSON.
 * This function will down-cast MULTI* objects to their single form
 *
 */
inline Rcpp::List create_geojson_downcast(
      Rcpp::DataFrame& data,
      Rcpp::List& data_types, 
      Rcpp::List& params,
      Rcpp::List& lst_defaults,
      std::unordered_map< std::string, std::string >& layer_colours,
      Rcpp::StringVector& layer_legend,
      int& data_rows,
      std::string& geometry_column,
      bool jsonify_legend
  ) 
```



```c++
/*
 * expects `data` to be data.frame withn lon & lat columns. The geometry_columns
 * argument is a named list, list(myGeometry = c("lon","lat")), where 'myGeometry'
 * will be returned inside the 'geometry' object of the GeoJSON
 */
inline Rcpp::List create_geojson(
    Rcpp::DataFrame& data,
    Rcpp::List& data_types,
    Rcpp::List& params,
    Rcpp::List& lst_defaults,
    std::unordered_map< std::string, std::string >& layer_colours,
    Rcpp::StringVector& layer_legend,
    int& data_rows,
    Rcpp::List& geometry_columns,
    bool jsonify_legend
)
```

```c++
/*
 * expects `data` to be data.frame withn lon & lat & elev columns. The 'bool elevation'
 * argument must be set to 'true', and the 'geometry_columns' should contain an 'elevation'
 * value - 'geometry_column <- list( geometry = c("lon","lat","elevation") )'
 */
inline Rcpp::List create_geojson(
    Rcpp::DataFrame& data,
    Rcpp::List& data_types,
    Rcpp::List& params,
    Rcpp::List& lst_defaults,
    std::unordered_map< std::string, std::string >& layer_colours,
    Rcpp::StringVector& layer_legend,
    int& data_rows,
    Rcpp::List& geometry_columns,
    bool jsonify_legend,
    bool elevation
)
```

```c++
/*
 * expects `data` to be data.frame withn a polyline
 */
inline Rcpp::List create_polyline(
    Rcpp::DataFrame& data,
    Rcpp::List& data_types,
    Rcpp::List& params,
    Rcpp::List& lst_defaults,
    std::unordered_map< std::string, std::string >& layer_colours,
    Rcpp::StringVector& layer_legend,
    int& data_rows,
    Rcpp::StringVector geometry_columns,
    bool jsonify_legend
)
```

# Example

Here's an example implementation of the R, cpp and hpp files required to convert R data to pseudo-GeoJSON

**widgetpoint.R**

```r
#' Widget Point
#'
#' Converts an `sf` object with POINT geometriers into JSON for plotting in an htmlwidget
#'
#' @param data `sf` object with POINT geometries
#' @param fill_colour string specifying column of `sf` to use for the fill colour
#' @param legend logical indicating if legend data will be returned
#' @param json_legend logical indicating if the lgend will be returned as JSON or a list
#'
#' @examples
#'
#' l <- widget_point( data = capitals, fill_colour = "country", legend = FALSE )
#'
#' @export
widget_point <- function( data,
                          fill_colour,
                          legend = TRUE,
                          json_legend = TRUE ) {

  l <- list()
  l[["fill_colour"]] <- force( fill_colour )
  l[["legend"]] <- legend

  data_types <- vapply( data, function(x) class(x)[[1]], "")

  js_data <- rcpp_widget_point( data, data_types, l, c("geometry"), json_legend )

  return( js_data )
}
```

**widgetpoint.cpp**

```c++
#include <Rcpp.h>
#include "spatialwidget/spatialwidget.hpp"
#include "spatialwidget/spatialwidget_defaults.hpp"
#include "spatialwidget/layers/widgetpoint.hpp"

// [[Rcpp::export]]
Rcpp::List rcpp_widget_point(
    Rcpp::DataFrame data,
    Rcpp::List data_types,
    Rcpp::List params,
    Rcpp::StringVector geometry_columns,
    bool jsonify_legend ) {

  int data_rows = data.nrows();
  Rcpp::List defaults = point_defaults( data_rows );

  std::unordered_map< std::string, std::string > point_colours = spatialwidget::widgetpoint::point_colours;
  Rcpp::StringVector point_legend = spatialwidget::widgetpoint::point_legend;

  return spatialwidget::api::create_geojson(
    data,
    data_types,
    params,
    defaults,
    point_colours,
    point_legend,
    data_rows,
    geometry_columns,
    jsonify_legend
  );
}
```

**/layers/widgetpoint.hpp**

```c++
#ifndef SPATIALWIDGET_WIDGETPOINT_H
#define SPATIALWIDGET_WIDGETPOINT_H

#include <Rcpp.h>
namespace spatialwidget {
namespace widgetpoint {

// map between colour and opacity values
  std::unordered_map< std::string, std::string > point_colours = {
    { "fill_colour", "fill_opacity" }
  };

  // vector of possible legend components
  Rcpp::StringVector point_legend = Rcpp::StringVector::create(
    "fill_colour"
  );

} // namespace widgetpoint
} // namespace spatialwidget

#endif
```

## GeoJSON

**Atomise** 

When converting an `sf` object to GeoJSON it will typically create a FeatureCollection. 'Atomising' means it treats each row of the `sf` as it's own Feature, without creating a Feature Collection

For example, we can create a GeoJSON FeatureCollection, convert it to `sf` and back again

```{r}
feat1 <- '{"type":"Feature","properties":{"id":1},"geometry":{"type":"Point","coordinates":[0,0]}}'
feat2 <- '{"type":"Feature","properties":{"id":2},"geometry":{"type":"Point","coordinates":[1,1]}}'
geojson <- paste0('[{"type":"FeatureCollection","features":[',feat1,',',feat2,']}]')
sf <- geojsonsf::geojson_sf( geojson )
sf
```

and going back the other way creates a FeatureCollection.
```{r}
geo <- geojsonsf::sf_geojson( sf )
geo
```

If we set to 'atomise' then an array of Features is returned

```{r}
geojsonsf::sf_geojson( sf, atomise = TRUE )
```

This is useful for sending to an htmlwidget because each object can be parsed independently, without having to worry about iterating into a Featurecollection.

Therefore, most of the GeoJSON functions inside spatialwidget will return the 'atomised' form. 

They also return the geometry nested one level deeper, thus creating the pseudo-geojson. This is so an `sf` object with multiple `sfc` columns can be converted into a form easily parsable by javascript inside a widget.


This is designed to convert an `sf` object with one or more `sfc` columns

```
  /*
  * a variation on the atomise function to return an array of atomised features
  */
  inline Rcpp::StringVector to_geojson_atomise(
      Rcpp::DataFrame& sf,
      Rcpp::StringVector& geometries ) {
```

```{r}
geojson <- spatialwidget:::rcpp_geojson_sf(sf = arcs, geometries = c("origin","destination")) 
substr( geojson, 1, 500)
```

down-cast MULTI objects to simpler form. for ONE column

```
  // down-casts MULTIGEOMETRIES to their simpler geometry
  // only for one-column sfc objects
  inline Rcpp::StringVector to_geojson_downcast_atomise(
      Rcpp::DataFrame& sf,
      std::string geometry ) {
```

```{r}
geojson <- spatialwidget:::rcpp_sf_to_geojson_downcast( sf = capitals, geometry_column = "geometry" )
substr( geojson, 1, 500)
```


down-cast MULTI objects to simpler form. for TWO columns. It will repeat the other columsn to the correct length.

```
  inline Rcpp::StringVector to_geojson_downcast_atomise(
      Rcpp::DataFrame& sf,
      Rcpp::StringVector geometries )
    {
```

```{r}
feat1 <- '{"type":"Feature","properties":{"id":1},"geometry":{"type":"MultiPoint","coordinates":[[0,0],[2,2],[4,4]]}}'
feat2 <- '{"type":"Feature","properties":{"id":2},"geometry":{"type":"MultiPoint","coordinates":[[1,1],[3,3],[5,5]]}}'
sf1 <- geojsonsf::geojson_sf( feat1 )
sf2 <- geojsonsf::geojson_sf( feat2 )

sf <- cbind( sf1, sf2)

geojson <- spatialwidget:::rcpp_sf_to_geojson_multi_column_downcast( sf = sf, geometries = c("geometry","geometry.1"))
geojson
```


standard GeoJSON

```
inline Rcpp::StringVector to_geojson( Rcpp::DataFrame& sf, std::string geom_column )
```

```{r}
geojson <- spatialwidget:::rcpp_geojson( sf = capitals, geometry = "geometry")
substr( geojson, 1, 300)
```


data.frame with lon & lat columns

```
  inline Rcpp::StringVector to_geojson_atomise(
      Rcpp::DataFrame& df,
      Rcpp::List& geometries ) // i.e., list(origin = c("start_lon", "start_lat", destination = c("end_lon", "end_lat")))
  {
```

```{r}

```

```
  // list of geometries is designed for lon & lat columns of data
  inline Rcpp::StringVector to_geojson_z_atomise(
      Rcpp::DataFrame& df,
      Rcpp::List& geometries ) // i.e., list(origin = c("start_lon", "start_lat", destination = c("end_lon", "end_lat")))
  {
```

```{r}

```



